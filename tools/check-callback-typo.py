# -*- coding: utf-8 -*-

# GENERATED BY CHAT GPT5

"""
Find TypeScript functions starting with "On" that:
1) are declared as `function OnX(...) { ... }`,
2) are never called in the file,
3) are not present in the hardcoded allowlist.

Notes:
- Only classic function declarations are considered (e.g., `function OnFoo(...) {}`).
- Calls inside comments and string/template literals are ignored.
- The allowlist is hardcoded below.
"""

import argparse
import re
from pathlib import Path
from typing import List, Set, Tuple

# ------------ HARDCODED ALLOWLIST (EDIT THIS) ------------
ALLOWLIST: Set[str] = {
    # list for v1.0.1.0 (16/10/2025)
    "OngoingGlobal",
    "OngoingAreaTrigger",
    "OngoingCapturePoint",
    "OngoingEmplacementSpawner",
    "OngoingHQ",
    "OngoingInteractPoint",
    "OngoingMCOM",
    "OngoingPlayer",
    "OngoingScreenEffect",
    "OngoingSector",
    "OngoingSpawner",
    "OngoingSpawnPoint",
    "OngoingTeam",
    "OngoingVehicle",
    "OngoingVehicleSpawner",
    "OngoingWaypointPath",
    "OngoingWorldIcon",
    "OnAIMoveToFailed",
    "OnAIMoveToRunning",
    "OnAIMoveToSucceeded",
    "OnAIParachuteRunning",
    "OnAIParachuteSucceeded",
    "OnAIWaypointIdleFailed",
    "OnAIWaypointIdleRunning",
    "OnAIWaypointIdleSucceeded",
    "OnCapturePointCaptured",
    "OnCapturePointCapturing",
    "OnCapturePointLost",
    "OnGameModeEnding",
    "OnGameModeStarted",
    "OnMandown",
    "OnMCOMArmed",
    "OnMCOMDefused",
    "OnMCOMDestroyed",
    "OnPlayerDamaged",
    "OnPlayerDeployed",
    "OnPlayerDied",
    "OnPlayerEarnedKill",
    "OnPlayerEarnedKillAssist",
    "OnPlayerEnterAreaTrigger",
    "OnPlayerEnterCapturePoint",
    "OnPlayerEnterVehicle",
    "OnPlayerEnterVehicleSeat",
    "OnPlayerExitAreaTrigger",
    "OnPlayerExitCapturePoint",
    "OnPlayerExitVehicle",
    "OnPlayerExitVehicleSeat",
    "OnPlayerInteract",
    "OnPlayerJoinGame",
    "OnPlayerLeaveGame",
    "OnPlayerSwitchTeam",
    "OnPlayerUIButtonEvent",
    "OnPlayerUndeploy",
    "OnRayCastHit",
    "OnRayCastMissed",
    "OnRevived",
    "OnSpawnerSpawned",
    "OnTimeLimitReached",
    "OnVehicleDestroyed",
    "OnVehicleSpawned"
}
# ---------------------------------------------------------

def find_function_declarations(ts_code: str) -> Tuple[Set[str], List[Tuple[int, int, str]]]:
    """
    Detect `function OnX(...)` declarations.
    Returns:
      - set of names,
      - list of (start, endApprox, name) spans to exclude when searching for calls.
    """
    defs: Set[str] = set()
    spans: List[Tuple[int, int, str]] = []

    # Classic function declaration: function OnX(...) { ... }
    pat = re.compile(r'\bfunction\s+(On[A-Za-z0-9_]*)\s*\(')
    for m in pat.finditer(ts_code):
        name = m.group(1)
        defs.add(name)
        # Approximate end at the first '{' after the params
        brace_pos = ts_code.find('{', m.end())
        span_end = brace_pos + 1 if brace_pos != -1 else m.end()
        spans.append((m.start(), span_end, name))

    return defs, spans


def find_calls(ts_code: str, names: Set[str], def_spans: List[Tuple[int, int, str]]) -> Set[str]:
    """
    Search for direct calls `Name(` outside the declaration spans.
    """
    if not names:
        return set()

    # Build a single regex for all names
    alt = '|'.join(sorted(map(re.escape, names), key=len, reverse=True))
    call_pat = re.compile(r'\b(' + alt + r')\s*\(')

    # Simple span check
    spans = [(a, b) for a, b, _ in def_spans]

    def in_any_span(pos: int) -> bool:
        for a, b in spans:
            if a <= pos < b:
                return True
        return False

    called: Set[str] = set()
    for m in call_pat.finditer(ts_code):
        if in_any_span(m.start()):
            continue
        called.add(m.group(1))

    return called


def main():
    parser = argparse.ArgumentParser(description="Report unused `On*` function declarations not in the hardcoded allowlist.")
    parser.add_argument("file", help="Path to the TypeScript file")
    args = parser.parse_args()

    ts_path = Path(args.file)
    src = ts_path.read_text(encoding="utf-8")

    on_defs, def_spans = find_function_declarations(src)
    called = find_calls(src, on_defs, def_spans)

    unused = sorted([name for name in on_defs if name not in called and name not in ALLOWLIST])

    # print(f"File: {ts_path}")
    # print(f"Allowlist ({len(ALLOWLIST)}): {', '.join(sorted(ALLOWLIST)) or '(empty)'}")
    # print(f"Found On* function declarations: {len(on_defs)}")
    # print(f"Called On* functions: {len(called)}")
    # print("\nUnused and not allowlisted:")

    if unused:
        print("\nERROR: The follozing functions may be callbacks with a typo:")
        for name in unused:
            print(f"  - {name}")
    else:
        print("\nOK: no callback with typo found")

if __name__ == "__main__":
    main()
